%{
open Core.Term
open Core.Operators.BinaryOperators
open Core.Operators.InternalOperator
open Helpers.GrammarHelpers
%}

// The start token becomes a parser function in the compiled code:
%start start

// Regular tokens
%token LPAR
%token RPAR
%token LBRACK
%token RBRACK
%token DOUBLECOLON
%token ARROW
%token PLUS
%token COMMA
%token MINUS 
%token TIMES
%token DIV 
%token MOD
%token AND
%token OR
%token EQUAL
%token NOTEQUAL
%token LESS
%token LESSEQUAL
%token GREATER
%token GREATEREQUAL
%token TRUE
%token FALSE
%token IF
%token THEN
%token ELSE
%token <string> IDENT
%token <int> NUM

// Misc tokens
%token EOF

// This is the type of the data produced by a successful reduction of the 'start'
// symbol:
%type < Core.Term.Term > start

%%

// These are the rules of the grammar along with the F# code of the 
// actions executed as rules are reduced.  
start:
	| term EOF { $1 }    

term: 
	| abs { $1 }

abs:
	| IDENT ARROW abs { Abs($1, $3) }
	| cond { $1 }

cond:
    | IF cond THEN cond ELSE cond { IfThenElse($2, $4, $6) }
    | disj { $1 }

disj:
    | disj OR conj { BoolOperation($1, $3, Or) }
    | conj { $1 }

conj:
    | conj AND comp { BoolOperation($1, $3, And) }
    | comp { $1 }

comp:
    | list EQUAL list { ComparisonOperation($1, $3, Equals) }
    | list NOTEQUAL list { ComparisonOperation($1, $3, NotEquals) }
    | list LESS list { ComparisonOperation($1, $3, LessThan) }
    | list LESSEQUAL list { ComparisonOperation($1, $3, LessThanOrEqual) }
    | list GREATER list { ComparisonOperation($1, $3, GreaterThan) }
    | list GREATEREQUAL list { ComparisonOperation($1, $3, GreaterThanOrEqual) }
    | list { $1 }
  
list:
    | expr { $1 }
    | expr DOUBLECOLON list { ConsList($1, $3) }
    
expr:
    | expr PLUS factor { NumOperation($1, $3, Plus) }
    | expr MINUS factor { NumOperation($1, $3, Minus) }
    | factor { $1 }
    
factor:
    | factor TIMES app { NumOperation($1, $3, Times) }
    | factor DIV app { NumOperation($1, $3, Divide) }
    | factor MOD app { NumOperation($1, $3, Mod) }
    | app { $1 }

app: 
	| app atom { App($1, $2) }
	| atom { $1 }

atom:
    | NUM { Num($1) }
    | TRUE { Bool(true) }
    | FALSE { Bool(false) }
	| IDENT { Var($1) }
	| LPAR term RPAR { $2 }
	| LBRACK RBRACK { EmptyList }
	| LBRACK seq RBRACK { ListTermToTerm $2 }

seq:
    | term { [$1] }
    | term COMMA { [$1] }
    | term COMMA seq { $1 :: $3 }